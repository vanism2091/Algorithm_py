<!-- TOC -->
- [4ë¶€ ë¹„ì„ í˜• ìë£Œêµ¬ì¡°](#4ë¶€-ë¹„ì„ í˜•-ìë£Œêµ¬ì¡°)
- [12ì¥ graph](#12ì¥-graph)
  - [ê°œë…](#ê°œë…)
    - [ì˜¤ì¼ëŸ¬ ê²½ë¡œ](#ì˜¤ì¼ëŸ¬-ê²½ë¡œ)
    - [í•´ë°€í„´ ê²½ë¡œ](#í•´ë°€í„´-ê²½ë¡œ)
    - [ê·¸ë˜í”„ ìˆœíšŒ](#ê·¸ë˜í”„-ìˆœíšŒ)
    - [ë°±íŠ¸ë˜í‚¹](#ë°±íŠ¸ë˜í‚¹)
    - [ì œì•½ ì¶©ì¡± ë¬¸ì œ](#ì œì•½-ì¶©ì¡±-ë¬¸ì œ)
  - [ë¬¸ì œ í’€ì´](#ë¬¸ì œ-í’€ì´)
  - [ë¬¸ì œë³„ ë‚˜ë§Œì˜ ì •ë¦¬](#ë¬¸ì œë³„-ë‚˜ë§Œì˜-ì •ë¦¬)
    - [33](#33)
    - [37](#37)
  - [ê°„ë‹¨ ì •ë¦¬](#ê°„ë‹¨-ì •ë¦¬)
    - [[ì°¸ê³ ] NP ë³µì¡ë„)](#ì°¸ê³ -np-ë³µì¡ë„)
    - [[íŒŒì´ì¬] ì¤‘ì²© í•¨ìˆ˜](#íŒŒì´ì¬-ì¤‘ì²©-í•¨ìˆ˜)
    - [[ë¬¸ë²•] ê°ì²´ ë³µì‚¬](#ë¬¸ë²•-ê°ì²´-ë³µì‚¬)
    - [[ì°¸ê³ ] ìˆœì—´ê³¼ ì¡°í•©](#ì°¸ê³ -ìˆœì—´ê³¼-ì¡°í•©)
    - [[íŒŒì´ì¬] defaultdict ìˆœíšŒ ë¬¸ì œ](#íŒŒì´ì¬-defaultdict-ìˆœíšŒ-ë¬¸ì œ)
  - [ì°¸ê³ ](#ì°¸ê³ )

<!-- /TOC -->

# 4ë¶€ ë¹„ì„ í˜• ìë£Œêµ¬ì¡°
# 12ì¥ graph
## ê°œë…

<details>
<summary>ì°¸ê³ í•œ ë§í¬</summary>

- ì˜¤ì¼ëŸ¬ ê²½ë¡œ
  - [ìœ„í‚¤](https://en.wikipedia.org/wiki/Eulerian_path)
  - [ì˜¤ì¼ëŸ¬ ê²½ë¡œì™€ íšŒë¡œ_í‹°ìŠ¤í† ë¦¬](https://rain-bow.tistory.com/entry/%EC%98%A4%EC%9D%BC%EB%9F%AC-%EA%B2%BD%EB%A1%9C%EC%99%80-%ED%9A%8C%EB%A1%9CEulerian-trail-circuit)
- í•´ë°€í„´ ê²½ë¡œ
  - [ìœ„í‚¤](https://en.wikipedia.org/wiki/Hamiltonian_path)
  - 
</details>

### ì˜¤ì¼ëŸ¬ ê²½ë¡œ
- ì •ì˜
  -  In graph theory, an Eulerian trail (or Eulerian path) is a trail in a finite graph that visits every edge exactly once (allowing for revisiting vertices). Similarly, an Eulerian circuit or Eulerian cycle is an Eulerian trail that starts and ends on the same vertex.
  - ìœ í•œí•œ ê·¸ë˜í”„ì—ì„œ ëª¨ë“  edgeë¥¼ ì˜¤ë¡œì§€ í•œ ë²ˆë§Œ ë°©ë¬¸í•˜ëŠ” ê²½ë¡œ
  - ì‹œì‘ì ê³¼ ë ì ì´ ê°™ìœ¼ë©´ ì˜¤ì¼ëŸ¬ íšŒë¡œë¼ê³  í•œë‹¤.
  - An **Eulerian trail**, or **Euler walk** in an undirected graph is a walk that uses each edge exactly once. If such a walk exists, the graph is called traversable or semi-eulerian.
  - 
- í•„ìš” ì¶©ë¶„ ì¡°ê±´:
  - An undirected graph has an Eulerian cycle <=> 
    1. **every vertex has even degree** 
    2. (&&) all of its vertices with nonzero degree belong to a **single connected component**.
  - An undirected graph can be decomposed into edge-disjoint cycles if and only if all of its vertices have even degree. So, a graph has an Eulerian cycle if and only if it can be decomposed into edge-disjoint cycles and its nonzero-degree vertices belong to a single connected component.
    - A set of cycles ğ¶ of a graph ğº=(ğ‘‰,ğ¸) is **edge-disjoint** if the cycles ğ‘ğ‘–, ğ‘ğ‘—âˆˆğ¶ have no edges in common.
  - An undirected graph has an Eulerian trail if and only if exactly **zero or two vertices have odd degree**, and all of its vertices with nonzero degree belong to a single connected component
  - A directed graph has an Eulerian cycle if and only if **every vertex** has **equal in degree and out degree**, and all of its vertices with nonzero degree belong to a **single strongly connected component**. Equivalently, a directed graph has an Eulerian cycle if and only if it can be decomposed into edge-disjoint directed cycles and all of its vertices with nonzero degree belong to a single strongly connected component.
  - A directed graph has an Eulerian trail if and only if at most one vertex has (out-degree) âˆ’ (in-degree) = 1, at most one vertex has (in-degree) âˆ’ (out-degree) = 1, every other vertex has equal in-degree and out-degree, and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.
- ì±…ì—ì„œëŠ” "ëª¨ë“  ì •ì ì´ ì§ìˆ˜ ê°œì˜ ì°¨ìˆ˜ë¥¼ ê°–ëŠ”ë‹¤ë©´ ëª¨ë“  ë‹¤ë¦¬ë¥¼ í•œ ë²ˆì”©ë§Œ ê±´ë„ˆì„œ ë„ë‹¬í•˜ëŠ” ê²ƒì´ ì„±ë¦½í•œë‹¤"ê³  ì„¤ëª…í•˜ë‚˜, ì´ëŠ” ì˜¤ì¼ëŸ¬ íšŒë¡œì— ëŒ€í•œ ì„¤ëª…ì´ë‹¤. ì˜¤ì¼ëŸ¬ ê²½ë¡œëŠ” í™€ìˆ˜ ê°œì¸ ì •ì ì´ ì˜¤ì§ 2ê°œë§Œ ìˆì„ë•Œë©´ ë¨.

### í•´ë°€í„´ ê²½ë¡œ
- ì •ì˜
  - A **Hamiltonian path** or traceable path is a path that **visits each vertex of the graph exactly once**. A graph that contains a Hamiltonian path is called a traceable graph. A graph is Hamiltonian-connected if for every pair of vertices there is a Hamiltonian path between the two vertices.
  - A **Hamiltonian cycle**, Hamiltonian circuit, vertex tour or graph cycle is a cycle that visits each vertex exactly once. A graph that contains a Hamiltonian cycle is called a Hamiltonian graph.
  
- í•´ë°€í„´ ê²½ë¡œë¥¼ ì°¾ëŠ” ë¬¸ì œëŠ” ìµœì  ì•Œê³ ë¦¬ì¦˜ì´ ì—†ëŠ” ëŒ€í‘œì ì¸ NP-complete ë¬¸ì œì´ë‹¤.
- í•´ë°€í„´ ìˆœí™˜ ë¬¸ì œì˜ ì˜ˆ, íŠ¹íˆ ìµœë‹¨ ê±°ë¦¬ë¥¼ ì°¾ëŠ” ë¬¸ì œëŠ” ì™¸íŒì› ë¬¸ì œ(Travelling Salesman Problem)ë¡œë„ ìœ ëª…í•˜ë‹¤

### ê·¸ë˜í”„ ìˆœíšŒ
- DFS
  - ì¬ê·€
    ```
    procedure DFS(G, v) is
      label v as discovered
      for all directed edges from v to w that are in G.adjacentEdges(v) do
          if vertex w is not labeled as discovered then
              recursively call DFS(G, w)
    ```
    ```py
    def recursive_dfs(v, discovered=[]):
      discovered.append(v)
      for w in graph[v]:
        if not w in discovered:
          discovered = recursive_dfs(w, discovered)
      return discovered
    ```
  - ìŠ¤íƒ
    ```
    procedure DFS_iterative(G, v) is
        let S be a stack
        S.push(v)
        while S is not empty do
            v = S.pop()
            if v is not labeled as discovered then
                label v as discovered
                for all edges from v to w in G.adjacentEdges(v) do 
                    S.push(w)
    ```
    ```py
    def iterative_dfs(start_v):
      stack = [start_v]
      discovered = []
      while stack:
        v = stack.pop()
        if v not in discovered:
          discovered.append(v)
          for w in graph[v]:
            stack.append(w)
      return discovered
    ```
- BFS
  - í
    ```js
    procedure BFS(G, root) is
        let Q be a queue
        label root as explored
        Q.enqueue(root)
        while Q is not empty do
            v := Q.dequeue()
            if v is the goal then
                return v
            for all edges from v to w in G.adjacentEdges(v) do
                if w is not labeled as explored then
                    label w as explored
                    Q.enqueue(w)
    ```
    ```py
    def bfs(start_v):
      q = [start_v]
      explored = [start_v]
      while q:
        v = q.pop(0)
        for w in graph[v]:
          if w not in explored:
            explored.append(w)
            q.append(w)
      return explored
    ``` 
  - ì¬ê·€ë¡œëŠ” êµ¬í˜„ ë¶ˆê°€ëŠ¥

### ë°±íŠ¸ë˜í‚¹
- í•´ê²°ì±…ì— ëŒ€í•œ í›„ë³´ë¥¼ êµ¬ì¶•í•´ ë‚˜ì•„ê°€ë‹¤ ê°€ëŠ¥ì„±ì´ ì—†ë‹¤ê³  íŒë‹¨ë˜ëŠ” ì¦‰ì‹œ í›„ë³´ë¥¼ í¬ê¸°(ë°±íŠ¸ë™)í•´ ì •ë‹µì„ ì°¾ì•„ê°€ëŠ” ë²”ìš©ì ì¸ ì•Œê³ ë¦¬ì¦˜
- ì œì•½ ì¶©ì¡± ë¬¸ì œì— íŠ¹íˆ ìœ ìš©
- dfsì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” ëª¨ë“  ë°©ë²•
- dfsëŠ” ë°±íŠ¸ë˜í‚¹ì˜ ê³¨ê²©ì„ ì´ë£¨ëŠ” ì•Œê³ ë¦¬ì¦˜
- ì£¼ë¡œ ì¬ê·€ë¡œ êµ¬í˜„
- Pruning: ê°€ì§€ì¹˜ê¸°. ë¶ˆí•„ìš”í•œ ë¶€ë¶„ì„ ì¼ì° í•„ìš”.
  - ì„±ëŠ¥ì´ ì¢‹ì•„ì§

### ì œì•½ ì¶©ì¡± ë¬¸ì œ
- Constraint Satisfaction Problems: ìˆ˜ ë§ì€ ì œì•½ ì¡°ê±´ì„ ì¶©ì¡±í•˜ëŠ” ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” ìˆ˜í•™ ë¬¸ì œ
- ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ í’€ ìˆ˜ ìˆìŒ
- e.g. ìŠ¤ë„ì¿ , ì‹­ìë§í’€ì´, 8í€¸ ë¬¸ì œ, 4ìƒ‰ ë¬¸ì œ ë“± í¼ì¦ ë¬¸ì œ, ë°°ë‚­ ë¬¸ì œ, ë¬¸ìì—´ íŒŒì‹±, ì¡°í•© ìµœì í™” ë“±

## ë¬¸ì œ í’€ì´
ì¶œì²˜: [algorithm-interview ê¹ƒí—™](https://github.com/onlybooks/algorithm-interview/blob/master/README.md)

| ë²ˆí˜¸ | ì œëª© | ë‚œì´ë„ | ì¥ | í’€ì´ ì½”ë“œ |
| --- | --- | ---- | - | --- |
| 32 | [ì„¬ì˜ ê°œìˆ˜](https://leetcode.com/problems/number-of-islands/) | â˜…â˜… | 12ì¥. ê·¸ë˜í”„ | [32_200.py](32_200.py) |
| 33 | [ì „í™” ë²ˆí˜¸ ë¬¸ì ì¡°í•©](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) | â˜…â˜… | 12ì¥. ê·¸ë˜í”„ | [33_17.py](33_17.py) |
| 34 | [ìˆœì—´](https://leetcode.com/problems/permutations/) | â˜…â˜… | 12ì¥. ê·¸ë˜í”„ | [34_46.py](34_46.py)|
| 35 | [ì¡°í•©](https://leetcode.com/problems/combinations/) | â˜…â˜… | 12ì¥. ê·¸ë˜í”„ | [35_77.py](35_77.py)|
| 36 | [ì¡°í•©ì˜ í•©](https://leetcode.com/problems/combination-sum/) | â˜…â˜… | 12ì¥. ê·¸ë˜í”„ | [36_39.py](36_39.py) |
| 37 | [ë¶€ë¶„ ì§‘í•©](https://leetcode.com/problems/subsets/) | â˜…â˜… | 12ì¥. ê·¸ë˜í”„ | [37_78.py](37_78.py) |
| 38 | [ì¼ì • ì¬êµ¬ì„±](https://leetcode.com/problems/reconstruct-itinerary/) | â˜…â˜… | 12ì¥. ê·¸ë˜í”„ | [38_332.py](38_332.py)|
| 39 | [ì½”ìŠ¤ ìŠ¤ì¼€ì¤„](https://leetcode.com/problems/course-schedule/) | â˜…â˜… | 12ì¥. ê·¸ë˜í”„ | [39_207.py](39_207.py)|

## ë¬¸ì œë³„ ë‚˜ë§Œì˜ ì •ë¦¬
### 33
- ì „ì²´ì ì¸ ë…¼ë¦¬ëŠ” ìœ ì‚¬
- dictionary ê°œì„ . list ì•„ë‹ˆë¼ strìœ¼ë¡œ í•˜ëŠ”ê²Œ ë” ê°„í¸í•¨. ë¹ ë¥¸ê±´ ì˜ ëª¨ë¥´ê² ìŒ

### 37
** ë‹¤ì‹œ ë³´ê¸°
## ê°„ë‹¨ ì •ë¦¬
### [ì°¸ê³ ] [NP ë³µì¡ë„](https://en.wikipedia.org/wiki/NP_(complexity))
![np](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Complexity_subsets_pspace.svg/640px-Complexity_subsets_pspace.svg.png)
- **NP**<sup>Non-deterministic Polynomial time</sup>: ë¹„ê²°ì •ë¡ ì  íŠœë§ ê¸°ê³„(NTM, Non-deterministic Turing Machine)ë¡œ ë‹¤í•­ ì‹œê°„ ì•ˆì— í’€ ìˆ˜ ìˆëŠ” íŒì • ë¬¸ì œì˜ ì§‘í•©
  - NP is the set of problems that can be solved in polynomial time by a nondeterministic Turing machine
  - NP is the set of decision problems solvable in polynomial time by a nondeterministic Turing machine.
- ì„ì˜ì˜ ë¬¸ì œê°€ NP ë¬¸ì œì— ì†í•œë‹¤ iff ê²°ì •ë¡ ì  íŠœë§ ê¸°ê³„ë¡œ ë‹¤í•­ ì‹œê°„ì— ê²€ì¦ ê°€ëŠ¥í•œ/í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œ
- ì •ë¦¬í•˜ìë©´, Deterministic Turing Machineìœ¼ë¡œ ë‹¤í•­ì‹œê°„ ë‚´ì—
  - í’€ ìˆ˜ ìˆìŒ: P
  - ê²€ì¦í•  ìˆ˜ ìˆìŒ: NP
    - ~~ solved by NTM
  
- í•´ë°€í„´ ê²½ë¡œ ë¬¸ì œì™€ ì™¸íŒì› ë¬¸ì œ(tsp)
  - í•´ë°€í„´ ê²½ë¡œ: í•œ ë²ˆë§Œ ë°©ë¬¸í•˜ëŠ” ê²½ë¡œ
  - í•´ë°€í„´ ìˆœí™˜: í•œ ë²ˆë§Œ ë°©ë¬¸í•˜ì—¬ ì¶œë°œì§€ë¡œ ëŒì•„ì˜¤ëŠ” ê²½ë¡œ
  - tsp: í•œ ë²ˆë§Œ ë°©ë¬¸í•˜ì—¬ ì¶œë°œì§€ë¡œ ëŒì•„ì˜¤ëŠ” ê²½ë¡œ
![P, NP, NPC ê´€ê³„](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/P_np_np-complete_np-hard.svg/2560px-P_np_np-complete_np-hard.svg.png)
- NP-Complete ë¬¸ì œë‹¤
  - NPë¬¸ì œì´ë‹¤.
  - && NP-Hard ë¬¸ì œì´ë‹¤.
### [íŒŒì´ì¬] ì¤‘ì²© í•¨ìˆ˜
- ì¤‘ì²© í•¨ìˆ˜: í•¨ìˆ˜ ë‚´ì— ìœ„ì¹˜í•œ ë˜ ë‹¤ë¥¸ í•¨ìˆ˜
- ì¥ì 
  - ë¶€ëª¨ í•¨ìˆ˜ì˜ ë³€ìˆ˜ë¥¼ ììœ ë¡­ê²Œ ì½ì„ ìˆ˜ ìˆë‹¤
  - ì‹¤ë¬´ì—ì„œ ìì£¼ ì“°ì´ëŠ” í¸ ì•„ë‹ˆì§€ë§Œ ë‹¨ì¼ í•¨ìˆ˜ë¡œ í•´ê²°í•´ì•¼ í•˜ëŠ” ê²½ìš°ê°€ ì¦ì€ ì½”í…Œì—ì„œ ë§¤ìš° ìì£¼ ì“°ì¸ë‹¤.
- ë‹¨ì 
  - ë¶€ëª¨ ë°–ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤
  - ìì‹ í•¨ìˆ˜ ë‚´ì—ì„œ ì¬í• ë‹¹ì´ ì¼ì–´ë‚  ê²½ìš° ì°¸ì¡° IDê°€ ë³€ê²½ë˜ì–´ ë³„ë„ì˜ ë¡œì»¬ ë³€ìˆ˜ë¡œ ì„ ì–¸ëœë‹¤.
- ì˜ˆì œ
  - ì¤‘ì²©í•¨ìˆ˜ê°€ ë¶€ëª¨ í•¨ìˆ˜ì˜ ë³€ìˆ˜ë¥¼ ê³µìœ í•˜ëŠ” ê²½ìš°
    ```py
    def outer_func(t: str):
      text: str = t
      
      def inner_func():
        # ì¬í• ë‹¹ ì‹œ, ì½”ë“œ ìˆœì„œê°€ ì¤‘ìš”í•´ì§„ë‹¤. print ì´í›„ì— ì¬í• ë‹¹í•˜ë©´ ì•„ë˜ì™€ ê°™ì€ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
        ###  UnboundLocalError: local variable 'text' referenced before assignment
        # text = "haha"
        print(text)
      
      inner_func()
      print(text)
      
    outer_func('Hello!')
    ```
  - ì—°ì‚°ì ì¡°ì‘ê³¼ ì¬í• ë‹¹
    ```py
    def outer_func(a: List[int]):
      b: List[int] = a
      print(id(b), b)

      def inner_func_1():
          # ì—°ì‚°ì ì¡°ì‘. idëŠ” ë°”ë€Œì§€ ì•ŠìŒ. outer ë³€ìˆ˜ê°€ ë°”ë€œ
          b.append(4)
          print(id(b), b)
      
      def inner_func_2():
          # ì¬í• ë‹¹. idëŠ” ë°”ë€œ. outerì— ì˜í–¥x
          b = [3, 4, 5]
          print(id(b), b)

      def inner_func_3():
          print(id(b), b)
      
      
      inner_func_1()
      inner_func_2()
      inner_func_3()

    outer_func([1, 2, 3])
    # 140628217795968 [1, 2, 3]
    # 140628217795968 [1, 2, 3, 4]
    # 140628217796096 [3, 4, 5]
    # 140628217795968 [1, 2, 3, 4]
    ```
  - 

### [ë¬¸ë²•] ê°ì²´ ë³µì‚¬
- íŒŒì´ì¬ì—ì„œ, ëª¨ë“  ê²ƒì€ **ê°ì²´**ë‹¤
  - ë¶ˆë³€ / ê°€ë³€ ê°ì²´ 
  - í• ë‹¹ ì‹œ ê°’ì„ ë³µì‚¬í•˜ì§€ ì•Šìœ¼ë©´, ë³€ìˆ˜ì— ê°’ì„ í• ë‹¹í•˜ëŠ” ëª¨ë“  í–‰ìœ„ëŠ”
    - **ê°’ ê°ì²´ì— ëŒ€í•œ ì°¸ì¡°**ê°€ ëœë‹¤
  - ì°¸ì¡°ê°€ ê°€ë¦¬í‚¤ëŠ” ì›ë˜ ê°’ì„ ë³€ê²½í•˜ë©´, ëª¨ë“  ì°¸ì¡°, ì¦‰ ëª¨ë“  ë³€ìˆ˜ì˜ ê°’ ë˜í•œ í•¨ê»˜ ë³€ê²½ëœë‹¤.
- ì°¸ì¡°ê°€ ë˜ì§€ ì•Šë„ë¡ ê°’ì„ ë³µì‚¬í•˜ëŠ” ë°©ë²•
  1. [:], ê°’ ë³µì‚¬í•˜ëŠ” ê°€ì¥ ê°„ë‹¨í•œ ë°©ë²• (shallow copy)
  2. `d = a.copy()` (shallow copy)
  3. deepcopy
     ```py
     import copy
     a = [1, [2, [3, 4], 5]]
     b = copy.deepcopy(a)
     ```
### [ì°¸ê³ ] ìˆœì—´ê³¼ ì¡°í•©
- ìˆœì—´: ìˆœì„œëŒ€ë¡œ nê°œì˜ elements ì¤‘ rê°œì˜ elementsë¥¼ ë½‘ì„ ê²½ìš°ì˜ ìˆ˜
  $$_nP_r = \frac{n!}{(n-r)!}$$
- ì¡°í•©: ìˆœì„œ ìƒê´€ x nê°œì˜ elements ì¤‘ rê°œì˜ elementsë¥¼ ë½‘ì„ ê²½ìš°ì˜ ìˆ˜
  $$_nC_r = \frac{n!}{r!(n-r)!}$$
  - ì¡°í•©ì„ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í•  ìˆ˜ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜?

### [íŒŒì´ì¬] defaultdict ìˆœíšŒ ë¬¸ì œ

## ì°¸ê³ 
- https://docs.python.org/3/library/collections.html
- https://docs.python.org/ko/3/library/heapq.html
- https://stackoverflow.com/questions/10291997/how-can-i-do-assignments-in-a-list-comprehension



